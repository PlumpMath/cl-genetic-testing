(in-package :cl-genetic-testing.cl)

(defclass cl-program (program)
  ((terminals :accessor prog-terminals :initarg :terminals)
   (functions :accessor prog-functions :initarg :functions)
   (code :accessor prog-code :initargs :code)
   (func :accessor prog-func)))

(defmethod run ((p cl-program) &rest args)
  (let ((func (if (slot-boundp p 'func)
                  (slot-value p 'func)
                  (update-prog-func p))))
    (funcall func args)))
(defun update-prog-func (prog)
  (setf (slot-value prog 'func)
        (eval `(lambda (args)
                 ,(slot-value prog 'code)))))
(defmethod generate-random ((program-class (eql 'cl-program))
                            &key
                              funcs (n-args 0)
                            &allow-other-keys)
  (let ((new-prog (make-instance 'cl-program :functions funcs
                                             :terminals (mapcar (lambda (n) `(elt args ,n))
                                                                (range n-args)))))
    (setf (slot-value new-prog 'code) (generate-subtree new-prog))
    new-prog))

(defun generate-subtree (prog &optional (max-depth 5))
  (if (or (zerop max-depth)
          (< (random 1.0) 0.5))
      (alexandria:random-elt (slot-value prog 'terminals))
      (let ((func (alexandria:random-elt (slot-value prog 'functions))))
        `(,(car func) ,@(iter:iter (iter:repeat (second func))
                          (iter:collect (generate-subtree prog (1- max-depth))))))))
(defun codesize (code prog)
  (if (or (not (consp code))
          (member code (slot-value prog 'terminals)))
      1
      (iter:iter (iter:for item :in code)
        (iter:sum (codesize item prog)))))
(defun replace-random-subtree (code replacement prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      replacement
      (let ((element (alexandria:random-elt (rest code))))
        (mapcar (lambda (e) (if (eq e element)
                           (replace-random-subtree e replacement prog)
                           e))
                code))))

(defun random-subtree (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      code
      (random-subtree (alexandria:random-elt (rest code)) prog)))

(defmethod make-child ((program1 cl-program) (program2 cl-program))
  (let ((new-prog (make-instance 'cl-program :functions (slot-value program1 'functions)
                                             :terminals (slot-value program1 'terminals))))
    (setf (slot-value new-prog 'code) (replace-random-subtree (slot-value program1 'code)
                                                       (random-subtree (slot-value program2 'code)
                                                                       program2)
                                                       new-prog))
    new-prog))
(defmethod mutate ((prog cl-program))
  (setf (slot-value prog 'code) (replace-random-subtree (slot-value prog 'code)
                                                 (generate-subtree prog)
                                                 prog)))
(defparameter *dataset* '((nil nil nil nil)
                          (nil t t nil)
                          (nil t nil t)
                          (nil nil t t)
                          (nil t t t)
                          (t t nil nil)
                          (t nil t nil)
                          (t nil nil t)))
(defparameter *funcs* '((and 2) (or 2) (not 1)))
