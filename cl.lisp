(in-package :cl-genetic-testing.cl)

(defclass cl-program (program)
  ((transforms :accessor prog-transforms :initarg :transforms)
   (terminals :accessor prog-terminals :initarg :terminals)
   (functions :accessor prog-functions :initarg :functions)
   (code :accessor prog-code :initargs :code)
   (func :accessor prog-func)))

(defmethod run ((p cl-program) &rest args)
  (let ((func (if (slot-boundp p 'func)
                  (slot-value p 'func)
                  (update-prog-func p))))
    (funcall func args)))
(defun update-prog-func (prog)
  (setf (slot-value prog 'func)
        (eval `(lambda (args)
                 ,(slot-value prog 'code)))))
(defmethod generate-random ((program-class (eql 'cl-program))
                            &key
                              funcs (n-args 0) transforms
                            &allow-other-keys)
  (let ((new-prog (make-instance 'cl-program :functions funcs
                                             :terminals (mapcar (lambda (n) `(elt args ,n))
                                                                (range n-args))
                                             :transforms transforms)))
    (setf (slot-value new-prog 'code) (generate-subtree new-prog))
    new-prog))

(defun generate-subtree (prog &optional (max-depth 5))
  (if (or (zerop max-depth)
          (< (random 1.0) 0.5))
      (alexandria:random-elt (slot-value prog 'terminals))
      (let ((func (alexandria:random-elt (slot-value prog 'functions))))
        `(,(car func) ,@(iter:iter (iter:repeat (second func))
                          (iter:collect (generate-subtree prog (1- max-depth))))))))
(defun codesize (code prog)
  (if (or (not (consp code))
          (member code (slot-value prog 'terminals)))
      1
      (iter:iter (iter:for item :in code)
        (iter:sum (codesize item prog)))))
(defun replace-random-subtree (code replacement prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      replacement
      (let ((element (alexandria:random-elt (rest code))))
        (mapcar (lambda (e) (if (eq e element)
                           (replace-random-subtree e replacement prog)
                           e))
                code))))
(defun transform-random-subtree (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      (let ((transforms (remove-if-not #'identity (slot-value prog 'transforms)
                                       :key (lambda (tr) (funcall (car tr) code)))))
        (if transforms
            (funcall (cadr (alexandria:random-elt transforms))
                     code)
            code))
      (let ((element (alexandria:random-elt (rest code))))
        (mapcar (lambda (e) (if (eq e element)
                           (transform-random-subtree e prog)
                           e))
                code))))

(defun random-subtree (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      code
      (random-subtree (alexandria:random-elt (rest code)) prog)))

(defmethod make-child ((program1 cl-program) (program2 cl-program))
  (let ((new-prog (make-instance 'cl-program :functions (slot-value program1 'functions)
                                             :terminals (slot-value program1 'terminals)
                                             :transforms (slot-value program1 'transforms))))
    (setf (slot-value new-prog 'code) (replace-random-subtree (slot-value program1 'code)
                                                       (random-subtree (slot-value program2 'code)
                                                                       program2)
                                                       new-prog))
    new-prog))
(defmethod mutate ((prog cl-program))
  (setf (slot-value prog 'code) (replace-random-subtree (slot-value prog 'code)
                                                        (generate-subtree prog)
                                                        prog))
  (if (< 0.5 (random 1.0))
      (setf (slot-value prog 'code) (transform-random-subtree (slot-value prog 'code)
                                                              prog))))
(defparameter *dataset* '((nil nil nil nil)
                          (nil t t nil)
                          (nil t nil t)
                          (nil nil t t)
                          (nil t t t)
                          (t t nil nil)
                          (t nil t nil)
                          (t nil nil t)))
(defparameter *funcs* '((and 2) (or 2) (not 1)))
(defparameter *transforms* `((,(lambda (c)
                                 (iter:iter (iter:for f :in (rest c))
                                   (iter:thereis (and (consp f)
                                                      (eq (car c) (car f))))))
                              ,(lambda (c)
                                 (cons (car c)
                                       (iter:iter (iter:for f :in (rest c))
                                         (if (and (consp f)
                                                  (eq (car c) (car f)))
                                             (iter:unioning (rest f) :test #'equal)
                                             (iter:adjoining f :test #'equal))))))
                             (,(lambda (c)
                                 (iter:iter outer
                                   (iter:initially (setq cdrs c))
                                   (iter:for cdrs :next (cdr cdrs))
                                   (iter:while (cdr cdrs))
                                   (if (and (consp (car cdrs))
                                            (not (eq (caar cdrs)
                                                     'not)))
                                       (iter:iter
                                         (iter:for item :in (cdr cdrs))
                                         (if (and (consp item)
                                                  (eq (caar cdrs)
                                                      (car item)))
                                             (return-from outer t))))))
                              ,(lambda (c)
                                 (let ((h (make-hash-table)))
                                   (iter:iter
                                     (iter:for item :in (cdr c))
                                     (if (eq (car item)
                                             'not)
                                         (alexandria:appendf (gethash (car item) h) item)
                                         (alexandria:unionf (gethash (car item) h) (cdr item)
                                                            :test #'equal)))
                                   (cons (car c)
                                         (iter:iter
                                           (iter:for (k v) :in-hashtable h)
                                           (iter:collect (cons k v)))))))))