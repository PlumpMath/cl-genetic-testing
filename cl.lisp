(in-package :cl-genetic-testing.cl)

(defclass cl-program (program)
  ((transforms :accessor prog-transforms :initarg :transforms)
   (terminals :accessor prog-terminals :initarg :terminals)
   (functions :accessor prog-functions :initarg :functions)
   (code :accessor prog-code :initargs :code)
   (func :accessor prog-func)))

(defmethod run ((p cl-program) &rest args)
  (let ((func (if (slot-boundp p 'func)
                  (slot-value p 'func)
                  (update-prog-func p))))
    (funcall func args)))
(defun update-prog-func (prog)
  (setf (slot-value prog 'func)
        (eval `(lambda (args)
                 ,(slot-value prog 'code)))))
(defmethod generate-random ((program-class (eql 'cl-program))
                            &key
                              funcs (n-args 0) transforms
                            &allow-other-keys)
  (let ((new-prog (make-instance 'cl-program :functions funcs
                                             :terminals (mapcar (lambda (n) `(elt args ,n))
                                                                (range n-args))
                                             :transforms transforms)))
    (setf (slot-value new-prog 'code) (generate-subtree new-prog))
    new-prog))

(defun generate-subtree (prog &optional (max-depth 5))
  (if (or (zerop max-depth)
          (< (random 1.0) 0.5))
      (alexandria:random-elt (slot-value prog 'terminals))
      (let ((func (alexandria:random-elt (slot-value prog 'functions))))
        `(,(car func) ,@(iter:iter (iter:repeat (second func))
                          (iter:collect (generate-subtree prog (1- max-depth))))))))
(defun codesize (code prog)
  (if (or (not (consp code))
          (member code (slot-value prog 'terminals)))
      1
      (iter:iter (iter:for item :in code)
        (iter:sum (codesize item prog)))))
(defun replace-random-subtree (code replacement prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      replacement
      (let ((element (alexandria:random-elt (rest code))))
        (mapcar (lambda (e) (if (eq e element)
                           (replace-random-subtree e replacement prog)
                           e))
                code))))
(defun transform-random-subtree (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      (let ((transforms (remove-if-not #'identity (slot-value prog 'transforms)
                                       :key (lambda (tr) (funcall (car tr) code)))))
        (if transforms
            (funcall (cadr (alexandria:random-elt transforms))
                     code)
            code))
      (let ((element (alexandria:random-elt (rest code))))
        (mapcar (lambda (e) (if (eq e element)
                           (transform-random-subtree e prog)
                           e))
                code))))

(defun transform-subtrees (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random 2) 0))
      (let ((transforms (remove-if-not #'identity (slot-value prog 'transforms)
                                       :key (lambda (tr) (funcall (car tr) code)))))
        (if transforms
            (funcall (cadr (alexandria:random-elt transforms))
                     code)
            code))
      (cons (car code)
            (mapcar (lambda (e)
                      (transform-random-subtree e prog)
                      e)
                    (rest code)))))

(defun random-subtree (code prog)
  (if (or (member code (slot-value prog 'terminals) :test #'equal)
          (= (codesize code prog) 0)
          (= (random (codesize code prog)) 0))
      code
      (random-subtree (alexandria:random-elt (rest code)) prog)))

(defmethod make-child ((program1 cl-program) (program2 cl-program))
  (let ((new-prog (make-instance 'cl-program :functions (slot-value program1 'functions)
                                             :terminals (slot-value program1 'terminals)
                                             :transforms (slot-value program1 'transforms))))
    (setf (slot-value new-prog 'code) (replace-random-subtree (slot-value program1 'code)
                                                       (random-subtree (slot-value program2 'code)
                                                                       program2)
                                                       new-prog))
    new-prog))
(defmethod mutate ((prog cl-program))
  (let ((new-prog (make-instance 'cl-program :functions (slot-value prog 'functions)
                                             :terminals (slot-value prog 'terminals)
                                             :transforms (slot-value prog 'transforms))))
    (setf (slot-value new-prog 'code) (if (< 0.5 (random 1.0))
                                          (transform-subtrees (slot-value prog 'code)
                                                              prog)
                                          (replace-random-subtree (slot-value prog 'code)
                                                                  (generate-subtree prog)
                                                                  prog)))
    new-prog))

(defparameter *dataset* '((nil nil nil nil)
                          (nil t t nil)
                          (nil t nil t)
                          (nil nil t t)
                          (t t t t)
                          (t t nil nil)
                          (t nil t nil)
                          (t nil nil t)))
(defparameter *funcs* '((and 2) (or 2) (not 1)))
(defparameter *transforms* `((,(lambda (c)
                                 (if (member (car c)
                                             '(and or))
                                     (iter:iter (iter:for f :in (rest c))
                                       (iter:thereis (and (consp f)
                                                          (eq (car c) (car f)))))))
                              ,(lambda (c)
                                 (cons (car c)
                                       (iter:iter (iter:for f :in (rest c))
                                         (if (and (consp f)
                                                  (eq (car c) (car f)))
                                             (iter:unioning (rest f) :test #'equal)
                                             (iter:adjoining f :test #'equal))))))
                             (,(lambda (c)
                                 (and (eq (car c)
                                          'not)
                                      (eq (caadr c)
                                          'not)))
                              ,(lambda (c)
                                 (cadadr c)))
                             (,(lambda (c)
                                 (iter:iter outer
                                   (iter:for i :on (rest c))
                                   (iter:iter (iter:for j :in (rest i))
                                     (iter:in outer (iter:thereis (equal (car i) j))))))
                              ,(lambda (c)
                                 (cons (car c)
                                       (iter:iter (iter:for i :in (rest c))
                                         (iter:adjoining i :test #'equal)))))
                             (,(lambda (c)
                                 (and (consp c)
                                      (= (length c) 2)
                                      (member (car c)
                                              '(and or))))
                              ,(lambda (c)
                                 (cadr c)))
                             (,(lambda (c)
                                 (and (eq (car c) 'not)
                                      (consp (cadr c))
                                      (member (caadr c)
                                              '(and or))))
                              ,(lambda (c)
                                 (cons (if (eq 'and (caadr c))
                                           'or
                                           'and)
                                       (iter:iter (iter:for item :in (cdadr c))
                                         (iter:collect (list 'not item))))))))

